<!DOCTYPE html>
<html>
<head>
  <title>Matter.js Arm</title>
  <meta charset="utf-8"> <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; background-color: #f0f0f0; } /* 背景色をcanvasに直接指定 */
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

  <script>
    // const Engine = Matter.Engine, ... (以下略)

    // --- Matter.js の基本設定 ---
    // モジュールのエイリアス
    const Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Bodies = Matter.Bodies,
        Composite = Matter.Composite,
        Constraint = Matter.Constraint,
        Mouse = Matter.Mouse,
        MouseConstraint = Matter.MouseConstraint, // MouseConstraintも使う場合はエイリアス追加
        Events = Matter.Events; // Eventsも使う場合はエイリアス追加

    // エンジンを作成
    const engine = Engine.create();
    const world = engine.world;

    // レンダラーを作成
    const render = Render.create({
        element: document.body, // 描画対象の要素 (body直下にcanvasが作られる)
        engine: engine,
        options: {
            width: window.innerWidth,
            height: window.innerHeight,
            wireframes: false, // ワイヤーフレーム表示をオフに
            // background: '#f0f0f0' // 背景色はCSSで指定したので削除してもOK
        }
    });

    // レンダリングを実行
    Render.run(render);

    // ランナーを作成し、エンジンを実行
    const runner = Runner.create();
    Runner.run(runner, engine);

    // --- 腕の作成 ---
    const shoulderPosition = { x: 100, y: window.innerHeight - 100 };
    const upperArmLength = 100;
    const foreArmLength = 90;
    const handRadius = 15;
    const armThickness = 20;
    // --- 念のため Matter.Body エイリアスを作成 ---
    const Body = Matter.Body;
    // Collision group (パーツ同士が衝突しないように)
    const armGroup = Body.nextGroup(true); // Matter.Bodyのtypo修正: Body -> Matter.Body or just Body if destructured
    // 上腕
    const upperArm = Bodies.rectangle(shoulderPosition.x + upperArmLength / 2, shoulderPosition.y - 50, upperArmLength, armThickness, {
         collisionFilter: { group: armGroup }, // 修正: Matter.Body.nextGroupを使う
         chamfer: { radius: armThickness * 0.5 } // 角を丸める
    });

    // 前腕
    const foreArm = Bodies.rectangle(upperArm.position.x + upperArmLength / 2 + foreArmLength / 2, upperArm.position.y, foreArmLength, armThickness, {
        collisionFilter: { group: armGroup },
        chamfer: { radius: armThickness * 0.5 }
    });

    // 手
    const hand = Bodies.circle(foreArm.position.x + foreArmLength / 2 + handRadius, foreArm.position.y, handRadius, {
        collisionFilter: { group: armGroup },
        density: 0.0001 // 手を軽くしてマウスで動かしやすくする
    });

    // --- 関節 ---
    const shoulderJoint = Constraint.create({
        pointA: shoulderPosition,
        bodyB: upperArm,
        pointB: { x: -upperArmLength / 2, y: 0 },
        stiffness: 0.9,
        length: 0,
         render: { strokeStyle: '#E0B65A' } // 関節を可視化 (デバッグ用)
    });

    const elbowJoint = Constraint.create({
        bodyA: upperArm,
        bodyB: foreArm,
        pointA: { x: upperArmLength / 2, y: 0 },
        pointB: { x: -foreArmLength / 2, y: 0 },
        stiffness: 0.7,
        length: 0,
         render: { strokeStyle: '#E0B65A' }
    });

    const wristJoint = Constraint.create({
        bodyA: foreArm,
        bodyB: hand,
        pointA: { x: foreArmLength / 2, y: 0 },
        pointB: { x: 0, y: 0 },
        stiffness: 0.7,
        length: 5, // 少しだけ長さを与える
         render: { strokeStyle: '#E0B65A' }
    });

    // --- マウスとの接続 ---
    const mouse = Mouse.create(render.canvas);

    const mouseConstraintArm = Constraint.create({
         // pointA は mousemove で更新するので、初期値は適当でOK
        pointA: { x: mouse.position.x, y: mouse.position.y },
        bodyB: hand,
        pointB: { x: 0, y: 0 },
        stiffness: 0.08, // 少し硬くしてみる
        damping: 0.05,
        length: 0,
        render: { // マウスとの接続線も可視化
            visible: true,
            lineWidth: 1,
            strokeStyle: '#444',
            type: 'line' // 'line', 'pin', 'spring'
        }
    });

    // --- ワールドに追加 ---
    Composite.add(world, [
        upperArm,
        foreArm,
        hand,
        shoulderJoint,
        elbowJoint,
        wristJoint,
        mouseConstraintArm
        // 地面を追加してみる (デバッグ用)
        // Bodies.rectangle(window.innerWidth / 2, window.innerHeight + 30, window.innerWidth, 60, { isStatic: true })
    ]);

     // --- マウスイベントの処理 ---
    let mouseX = shoulderPosition.x; // 初期値を設定
    let mouseY = shoulderPosition.y - upperArmLength - foreArmLength; // 初期値を設定

    document.addEventListener('mousemove', (event) => {
         const canvasBounds = render.canvas.getBoundingClientRect();
         // マウス座標を Canvas 内の座標に変換
         mouseX = event.clientX - canvasBounds.left;
         mouseY = event.clientY - canvasBounds.top;

         // Render のスケールやオフセットを考慮して Matter.js のワールド座標に変換
         // (Renderの内部スケールが変わらない標準的な使い方なら、この変換は不要なことが多い)
         // mouseConstraintArm.pointA.x = mouseX;
         // mouseConstraintArm.pointA.y = mouseY;
         // 直接更新する代わりに、Renderのスケールを考慮したMouseオブジェクトを使うのが安全
    });

    // beforeUpdate イベントでマウスの位置を反映させる方が安定することが多い
    Events.on(engine, 'beforeUpdate', () => {
         // Mouseオブジェクトから最新のマウス座標を取得して反映
        mouseConstraintArm.pointA.x = mouse.position.x;
        mouseConstraintArm.pointA.y = mouse.position.y;

        // もし mouseConstraintArm だけを使う場合 (MouseConstraintなし)
        // mouseConstraintArm.pointA.x = mouseX;
        // mouseConstraintArm.pointA.y = mouseY;
    });

    // --- リサイズ対応 (より確実に) ---
    window.addEventListener('resize', () => {
        // レンダラーのサイズ更新
        render.canvas.width = window.innerWidth;
        render.canvas.height = window.innerHeight;
        render.options.width = window.innerWidth;
        render.options.height = window.innerHeight;

        // 肩の位置も再計算 (ウィンドウサイズに依存させる場合)
         shoulderPosition.x = 100; // 固定値のままか、割合で決めるか
        shoulderPosition.y = window.innerHeight - 100;
        shoulderJoint.pointA = { ...shoulderPosition }; // ConstraintのpointAも更新

         // Matter.js のビューポートも更新 (重要)
        Render.lookAt(render, {
            min: { x: 0, y: 0 },
            max: { x: window.innerWidth, y: window.innerHeight }
        });
    });

    // --- 最初のmouse positionの更新 ---
    // MouseConstraintを追加する場合（オプション）
    /*
    const mouseConstraintGeneral = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: {
            stiffness: 0.2,
            render: { visible: false }
        }
    });
    Composite.add(world, mouseConstraintGeneral);
    */


  </script>
</body>
</html>